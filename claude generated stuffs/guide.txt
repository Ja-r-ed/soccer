# X-Drive RoboCup Junior Soccer Robot Setup Guide

## Hardware Configuration

### Robot Specifications
- **Drive System**: X-Drive (4 omniwheels at 45° angles)
- **Main Controller**: OpenMV RT1062 (vision processing + EKF)
- **Motor Controller**: ESP32 (X-drive kinematics + game strategy)  
- **Sensor Controller**: ESP32 (ToF sensors + IMU support)
- **Manipulation**: Dribbler mechanism (no kicker)

### Pin Assignments

#### OpenMV RT1062
```
Camera: Built-in
I2C (IMU - if connected directly):
- P4 (SCL) → IMU SCL  
- P5 (SDA) → IMU SDA

UART Communication:
- UART1 (P0/P1) → Sensors ESP32
- UART3 (P7/P8) → Motors ESP32

Power: 3.3V from USB or external supply
```

#### ESP32 #1 - Sensors Controller
```
I2C (ToF Sensors):
- GPIO21 (SDA) → All ToF sensors SDA
- GPIO22 (SCL) → All ToF sensors SCL

XSHUT Control (ToF sensor addressing):
- GPIO4  → Sensor 1 XSHUT (Front-Right)
- GPIO5  → Sensor 2 XSHUT (Front-Left)
- GPIO18 → Sensor 3 XSHUT (Back-Right)  
- GPIO19 → Sensor 4 XSHUT (Back-Left)

UART (OpenMV Communication):
- GPIO16 (RX) ← OpenMV UART1 TX
- GPIO17 (TX) → OpenMV UART1 RX

Power: 3.3V → ToF sensors VCC, 5V → ESP32 VIN
```

#### ESP32 #2 - Motor Controller  
```
X-Drive Motor Control (assuming Cytron MD10C drivers):
- GPIO18 → Front-Left Motor PWM
- GPIO19 → Front-Left Motor DIR
- GPIO21 → Front-Right Motor PWM
- GPIO22 → Front-Right Motor DIR
- GPIO23 → Back-Left Motor PWM
- GPIO25 → Back-Left Motor DIR
- GPIO26 → Back-Right Motor PWM
- GPIO27 → Back-Right Motor DIR

Dribbler Control (H-bridge like L298N):
- GPIO32 → Dribbler PWM
- GPIO33 → Dribbler DIR1
- GPIO34 → Dribbler DIR2

UART (OpenMV Communication):
- GPIO16 (RX) ← OpenMV UART3 TX
- GPIO17 (TX) → OpenMV UART3 RX

Power: 5V → ESP32 VIN, Motor power from main battery (14.8V)
```

## X-Drive Kinematics

### Motor Positioning
```
    Front-Left (45°)    Front-Right (-45°)
         FL ↗                ↖ FR
           \                  /
            \                /
             \              /
              \            /
               \          /
                \        /
                 \      /
                  \    /
                   \  /
                    \/
                   ROBOT
                    /\
                   /  \
                  /    \
                 /      \
                /        \
               /          \
              /            \
             /              \
            /                \
           /                  \
         BL ↘                ↙ BR
    Back-Left (-45°)     Back-Right (45°)
```

### Velocity Equations
For desired robot velocities (vx, vy, ω):
```
Front-Left  = (vx + vy + ω) × √2
Front-Right = (vx - vy + ω) × √2  
Back-Left   = (vx + vy - ω) × √2
Back-Right  = (vx - vy - ω) × √2
```

Where:
- vx = forward/backward velocity (positive = toward opponent goal)
- vy = left/right velocity (positive = left strafe)
- ω = angular velocity (positive = counterclockwise rotation)

## Software Setup

### 1. OpenMV IDE Configuration
```python
# Install OpenMV IDE
# Connect OpenMV RT1062 via USB
# Upload the X-Drive localization code

# Camera settings for RoboCup field:
sensor.set_auto_gain(False, gain_db=10)
sensor.set_auto_whitebal(False)
sensor.set_auto_exposure(False, exposure_us=10000)
```

### 2. Arduino IDE ESP32 Setup
```cpp
// Board: "ESP32 Dev Module"
// Upload Speed: 921600
// Flash Frequency: 80MHz
// Flash Size: 4MB
// Partition Scheme: Default 4MB

// Required Libraries:
// - VL53L0X by Adafruit
// - Built-in HardwareSerial
```

### 3. ToF Sensor I2C Addressing
The code automatically assigns I2C addresses:
- Sensor 1 (Front-Right): 0x30
- Sensor 2 (Front-Left): 0x31  
- Sensor 3 (Back-Right): 0x32
- Sensor 4 (Back-Left): 0x33

## Calibration Procedures

### 1. Vision System Calibration

#### Goal Detection
```python
# Adjust these LAB thresholds in OpenMV code:
goal_blue_threshold = [(0, 15, -25, 25, -40, -10)]    # Blue goal
goal_yellow_threshold = [(30, 100, -10, 10, 20, 60)]  # Yellow goal
ball_threshold = [(20, 100, -20, 20, 20, 70)]         # Orange ball

# Calibration process:
# 1. Use OpenMV IDE's "Threshold Editor" tool
# 2. Point camera at each object under field lighting
# 3. Adjust LAB values until detection is reliable
# 4. Test at various distances and angles
```

#### Distance Estimation
```python
# Calibrate pixel-to-distance conversion:
def pixel_to_field_coords(self, pixel_x, pixel_y, area):
    # These values need calibration for your camera height/angle:
    if area > 2000:    distance = 30   # Very close
    elif area > 1000:  distance = 50   # Medium  
    elif area > 500:   distance = 80   # Far
    else:              distance = 120  # Very far
    
    # Measure actual distances and adjust these thresholds
```

### 2. ToF Sensor Calibration

Run the built-in calibration:
```cpp
// In Arduino Serial Monitor, send: CALIBRATE
// Follow prompts to place robot at known distances
// Compare measured vs. actual distances
// Adjust sensor configurations if needed
```

Expected accuracy:
- 10-50cm: ±2cm accuracy
- 50-100cm: ±5cm accuracy  
- 100cm+: ±10cm accuracy

### 3. Motor Calibration

#### X-Drive Movement Testing
```cpp
// Serial commands for testing:
// MOVE 1.0 0 0     - Move forward
// MOVE -1.0 0 0    - Move backward  
// MOVE 0 1.0 0     - Strafe left
// MOVE 0 -1.0 0    - Strafe right
// MOVE 0 0 0.5     - Rotate counterclockwise
// MOVE 0 0 -0.5    - Rotate clockwise

// Diagonal movement:
// MOVE 0.7 0.7 0   - Move diagonally forward-left
```

#### Dribbler Calibration
```cpp
// Test dribbler speeds:
// DRIBBLE_ON   - Start dribbling
// DRIBBLE_OFF  - Stop dribbling

// Adjust speed in code (0-255):
setDribbler(150);  // Moderate speed
setDribbler(200);  // High speed
```

### 4. EKF Parameter Tuning

#### Process Noise (Q Matrix)
```python
# Start with these values, adjust based on performance:
self.Q[0][0] = 0.1   # Position X noise
self.Q[1][1] = 0.1   # Position Y noise
self.Q[2][2] = 0.05  # Orientation noise (lower for gyro trust)
self.Q[3][3] = 0.2   # Velocity X noise  
self.Q[4][4] = 0.2   # Velocity Y noise
self.Q[5][5] = 0.1   # Angular velocity noise

# If position jumps too much: decrease values
# If position updates too slowly: increase values
```

#### Measurement Noise (R Matrix)
```python
# ToF sensor noise
R_tof = 4.0  # Increase if ToF readings are noisy

# Vision noise  
R_vision = [[16.0, 0], [0, 16.0]]  # Increase if vision is unreliable
```

## Game Strategy Configuration

### Playing Field Setup
```
RoboCup Junior Soccer Field (122cm × 183cm):

Yellow Goal ←------ 183cm ------→ Blue Goal
    |                                |
   122cm            Robot           122cm  
    |             Starting          |
    |             Position          |
Yellow Goal ←------ 183cm ------→ Blue Goal

Coordinate System:
- Origin: Center of field  
- X-axis: Toward blue goal (opponent)
- Y-axis: Toward left side of field
- Angles: 0° = facing blue goal
```

### Strategy States
The robot cycles through these behaviors:

1. **SEEK_BALL**: Rotate to find orange ball
2. **APPROACH_BALL**: Move toward detected ball
3. **DRIBBLE_BALL**: Activate dribbler and move toward goal
4. **SHOOT_BALL**: Maximum dribbler speed to "shoot"
5. **DEFEND**: Position between ball and own goal

### Manual Override
```cpp
// Serial commands for manual control:
// MANUAL - Switch to manual mode
// AUTO   - Return to autonomous mode
// STOP   - Emergency stop
// STATUS - Print robot status
```

## Troubleshooting

### Common Issues

#### Robot Doesn't Move Straight
**Symptoms**: Robot drifts or curves when commanded to move straight
**Solutions**:
- Check motor wiring and directions
- Calibrate individual motor speeds
- Verify omniwheel alignment at 45° angles
- Test each motor individually

#### ToF Sensors Interfering
**Symptoms**: Inconsistent distance readings, cross-talk between sensors
**Solutions**:
- Increase physical separation between sensors
- Use different timing budgets: `FAST` mode (20ms) vs `ACCURATE` mode (100ms)
- Shield sensors with small tubes/housings
- Disable problematic sensors: `DISABLE_n` command

#### Ball Detection Issues  
**Symptoms**: Ball not detected or false positives
**Solutions**:
- Recalibrate color thresholds under actual field lighting
- Adjust camera exposure and gain settings
- Increase minimum blob area threshold
- Test with actual RoboCup orange ball

#### EKF Position Drift
**Symptoms**: Robot position estimate drifts over time
**Solutions**:
- Recalibrate IMU (gyroscope bias)
- Reduce process noise (Q matrix values)
- Increase vision landmark update frequency
- Check for magnetic interference near IMU

### Performance Optimization

#### Speed vs. Accuracy Trade-offs
- **Fast Mode**: 20Hz updates, 20ms ToF timing budget
- **Accurate Mode**: 10Hz updates, 100ms ToF timing budget  
- **Balanced Mode**: 20Hz updates, 50ms ToF timing budget (recommended)

#### Competition Day Setup
1. Arrive early for field lighting calibration
2. Test all color thresholds under competition lighting
3. Verify ToF sensors detect field boundaries correctly
4. Run full autonomous test with actual game ball
5. Have backup manual control ready

### Advanced Features

#### Multi-Robot Communication (Future Enhancement)
```cpp
// ESP-NOW for robot-to-robot communication
// Share ball position, coordinate defensive strategies
// Avoid collisions with teammate robots
```

#### Advanced Ball Prediction
```python
# Track ball velocity and predict future position
# Intercept moving ball rather than chasing
# Account for ball bounces off walls
```

This setup provides a comprehensive foundation for competitive RoboCup Junior Soccer with your X-drive omniwheel robot!